# Задание

Взять шаблон приложения и на его основе реализовать табы по указанной в `app.component.html` разметке (в отдельном модуле, в отдельном каталоге). И содержимое, и заголовок должны поддерживать отображение других компонентов/произвольного html. 

По умолчанию активен первый таб. Должна поддерживаться возможность динамически добавить/убрать таб. При удалении активного таба, активным становится первый таб (если остался хотя бы один). Для оформления табов достаточно использовать 3 класса из `styles.css`. Приложение должно работать без `NO_ERRORS_SCHEMA/CUSTOM_ELEMENTS_SCHEMA` в `AppModule`.

Bonus: Сделать так, чтобы содержимое табов инициализировалось только при активации таба. Допускается изменение разметки.

## Решение
<details>
<summary>Основное задание</summary>
<div>

**Пояснение к исходникам. Описание порядка действий**.

1. Для начала создадим отсутствующие компоненты `tab`, `tab-title`, `tab-content` и поместим их в отдельный модуль.
Это сразу решает проблему с выводом ошибок и можно отключить их блокировку через `NO_ERRORS_SCHEMA`.

2. Теперь передадим в шаблон компонентов директиву `ng-content`.

Директива выводит в шаблоне то, что находится между тегами компонента. Это как раз и требуется в нашем случае.

3. По представленной структуре у нас нет входных параметров для вложенных компонентов, 
поэтому нам понадобится создать шаред-сервис.

Он нами будет использоваться, как синглтон, принадлежащий компоненту `tabs`, поэтому там и зарегистрируем этот провайдер.
Если зарегистрировать в модуле, этот класс будет общий для всех компонентов табов, а нам это не нужно.

Сервис будет хранить текущий индекс и `EventEmitter` для уведомления компонентов, какой таб активен.

4. Так как дочерние табы не знают какой они имеют индекс, мы его проставим самостоятельно. 
Для этого, используя наш синглтон класс, в компоненте `tab` проставим `tabIndex` для каждого компонента простым инкрементированием, 
который будет вызываться при создании компонента.

И передадим его непосредственно дочерним компонентам. Получить доступ к ним можно через декоратор `@ContentChild`.
Декоратор `@ContentChild` получает доступ к контенту, который располагается внутри его тегов.

```
  @ContentChild(TabTitleComponent) tabTitleComponent: TabTitleComponent;
  @ContentChild(TabContentComponent) tabContentComponent: TabContentComponent;
 
  ngAfterContentInit() {

    // set tab index for child component
    this.tabTitleComponent.tabIndex = this.tabIndex;
    this.tabContentComponent.tabIndex = this.tabIndex;

    if (!this.tabTitleComponent.activeTab) {
      this.tabsService.setTabIndex();
    }

  }
```  

На хук `ngAfterContentInit` (после инициализации вложенной части компонента) передаём индекс в `tab-title`, `tab-content` 
и заодно устанавливаем активный таб по умолчанию.

5. Зная индекс теперь добавим в `tab-title` событие обработки клика с помощью декоратора @HostListener (прослушивает события на компоненте).

```
  @HostListener('click') initTab() {
    this.tabsService.setTabIndex(this.tabIndex); // set active tab
  }
```
 
С помощью декоратора `@HostBinding` установим привязку активного класса.

```
  @HostBinding('class') activeTab = '';
```

Когда будет клик по компоненту, будет установлен класс.

```
  ngAfterContentInit() {
    this.subscription = this.tabsService.change.subscribe(tabIndex => {
      this.activeTab = tabIndex === this.tabIndex ? classActiveTab : '';
    });
  }
```

Тут суть в том, что по клику событие эмитится в сервис, который оповещает все подписанные компоненты об изменившимся активном табе.
И в хуке `ngAfterContentInit` мы делаем проверку, совпадает ли индекс или нет. 

6. Всё аналогично и в `tab-content`. Также подписываемся на сервис, а для скрытия компонента связываем свойство `hidden`, 
которое будет управлять видимостью компонента, в зависимости от активного класса. 

```
  @HostBinding('hidden') hidden = true;
```

</details>
 
